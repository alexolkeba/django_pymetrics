{% extends 'base.html' %}
{% load static %}
{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
    :root {
        --primary-color: #6366F1; /* Indigo-500 */
        --success-color: #34D399; /* Green-400 */
        --danger-color: #F87171; /* Red-400 */
        --background-color: #0F172A; /* Slate-900 */
        --surface-color: #1E293B; /* Slate-800 */
        --text-color: #F1F5F9; /* Slate-100 */
        --muted-text-color: #94A3B8; /* Slate-400 */
        --border-color: #334155; /* Slate-700 */
    }
    .game-body { background-color: var(--background-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 1rem; }
    .game-container { background-color: var(--surface-color); border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); width: 100%; max-width: 900px; overflow: hidden; }
    .game-header { background-color: rgba(0,0,0,0.2); padding: 1.5rem; text-align: center; border-bottom: 1px solid var(--border-color); }
    .game-header h2 { font-size: 1.75rem; font-weight: bold; margin: 0; }
    .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; padding: 1.5rem; border-bottom: 1px solid var(--border-color); }
    .stat-card { background-color: rgba(0,0,0,0.2); padding: 1rem; border-radius: 8px; text-align: center; }
    .stat-card .value { font-size: 1.75rem; font-weight: bold; color: var(--primary-color); }
    .stat-card .label { font-size: 0.8rem; color: var(--muted-text-color); text-transform: uppercase; font-weight: 600; }
    .game-area { padding: 2rem; text-align: center; }
    #pattern-display { display: flex; justify-content: center; align-items: center; gap: 1rem; margin-bottom: 2rem; }
    .pattern-item { background-color: var(--background-color); border: 1px solid var(--border-color); border-radius: 8px; width: 80px; height: 80px; display: flex; justify-content: center; align-items: center; font-size: 2rem; font-weight: bold; }
    .pattern-item.question-mark { color: var(--primary-color); }
    #options-container { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; max-width: 400px; margin: 0 auto; }
    .option-btn { background-color: rgba(0,0,0,0.2); border: 1px solid var(--border-color); color: var(--text-color); padding: 1rem; border-radius: 8px; font-size: 1.25rem; cursor: pointer; transition: all 0.2s; }
    .option-btn:hover { background-color: var(--primary-color); border-color: var(--primary-color); }
    .option-btn.correct { background-color: var(--success-color); animation: pulse 0.5s; }
    .option-btn.incorrect { background-color: var(--danger-color); animation: shake 0.5s; }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
    .modal-content { background-color: var(--surface-color); padding: 2.5rem; border-radius: 12px; border: 1px solid var(--border-color); max-width: 500px; width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.5); animation: modal-pop 0.3s ease-out; text-align: center; }
    @keyframes modal-pop { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    .btn { padding: 0.75rem 2rem; border: none; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.2s; background-color: var(--primary-color); color: var(--text-color); }
    #back-to-games-btn { position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.3); color: var(--text-color); padding: 0.5rem 1rem; border-radius: 8px; text-decoration: none; font-weight: bold; z-index: 10; }
</style>

<div class="game-body" data-game-list-url="{% url 'games:game_list' %}" data-csrf-token="{{ csrf_token }}">
    <a href="#" id="back-to-games-btn"><i class="fas fa-arrow-left"></i> Back to Games</a>

    <div class="game-container">
        <div class="game-header"><h2>Inductive Reasoning Challenge</h2></div>
        <div class="dashboard">
            <div class="stat-card"><div id="round-display" class="value">-</div><div class="label">Round</div></div>
            <div class="stat-card"><div id="score-display" class="value">0</div><div class="label">Score</div></div>
            <div class="stat-card"><div id="difficulty-display" class="value">-</div><div class="label">Difficulty</div></div>
            <div class="stat-card"><div id="timer-display" class="value">0s</div><div class="label">Time</div></div>
        </div>
        <div class="game-area">
            <div id="pattern-display"></div>
            <div id="options-container"></div>
        </div>
    </div>

    <!-- Modals -->
    <div id="instruction-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h3 style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">Inductive Reasoning Challenge</h3>
            <p style="margin: 1rem 0; color: var(--muted-text-color);">Identify the underlying rule in a sequence of numbers and find the missing element.</p>
            <p>The patterns will become more complex as you progress. Solve each puzzle as quickly and accurately as possible.</p>
            <button id="start-game-btn" class="btn" style="margin-top: 1.5rem;">Start Challenge</button>
        </div>
    </div>

    <div id="final-results-modal" class="modal">
        <div class="modal-content">
            <h3 style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">Challenge Complete!</h3>
            <div id="final-summary" style="margin: 1.5rem 0; font-size: 1.1rem; display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; text-align: left;"></div>
            <button id="return-to-games-final-btn" class="btn">Return to Games</button>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const gameBody = document.querySelector('.game-body');
    const backToGamesBtn = document.getElementById('back-to-games-btn');
    const instructionModal = document.getElementById('instruction-modal');
    const startGameBtn = document.getElementById('start-game-btn');
    const finalResultsModal = document.getElementById('final-results-modal');
    const returnToGamesFinalBtn = document.getElementById('return-to-games-final-btn');
    const roundDisplay = document.getElementById('round-display');
    const scoreDisplay = document.getElementById('score-display');
    const difficultyDisplay = document.getElementById('difficulty-display');
    const timerDisplay = document.getElementById('timer-display');
    const patternDisplay = document.getElementById('pattern-display');
    const optionsContainer = document.getElementById('options-container');
    const finalSummary = document.getElementById('final-summary');

    // --- Game Configuration ---
    const TOTAL_ROUNDS = 15;
    const BASE_SCORE_PER_ROUND = 100;
    const TIME_PENALTY_FACTOR = 5; // Points lost per second

    // --- Game State ---
    let currentRound = 0;
    let score = 0;
    let difficulty = 1;
    let gameEvents = [];
    let roundStartTime;
    let gameTimerInterval;
    let gameInProgress = false;

    // --- Pattern Generation Logic ---
    const patternGenerators = {
        1: () => { // Arithmetic Progression
            const start = Math.floor(Math.random() * 10) + 1;
            const diff = Math.floor(Math.random() * 5) + 2;
            const sequence = Array.from({ length: 4 }, (_, i) => start + i * diff);
            return { type: 'Arithmetic', sequence, answer: start + 4 * diff };
        },
        2: () => { // Geometric Progression
            const start = Math.floor(Math.random() * 4) + 2;
            const ratio = Math.floor(Math.random() * 2) + 2;
            const sequence = Array.from({ length: 4 }, (_, i) => start * Math.pow(ratio, i));
            return { type: 'Geometric', sequence, answer: start * Math.pow(ratio, 4) };
        },
        3: () => { // Fibonacci-like
            const a = Math.floor(Math.random() * 5) + 1;
            const b = Math.floor(Math.random() * 5) + a;
            const sequence = [a, b, a + b, a + 2 * b];
            return { type: 'Fibonacci-like', sequence, answer: (a + b) + (a + 2 * b) };
        },
        4: () => { // Squares/Cubes
            const start = Math.floor(Math.random() * 5) + 2;
            const power = (difficulty > 5 && Math.random() > 0.5) ? 3 : 2;
            const sequence = Array.from({ length: 4 }, (_, i) => Math.pow(start + i, power));
            return { type: `Power of ${power}`, sequence, answer: Math.pow(start + 4, power) };
        },
        5: () => { // Alternating Series
            const start1 = Math.floor(Math.random() * 10) + 1;
            const start2 = Math.floor(Math.random() * 10) + 20;
            const diff1 = Math.floor(Math.random() * 3) + 1;
            const diff2 = -(Math.floor(Math.random() * 3) + 1);
            const sequence = [start1, start2, start1 + diff1, start2 + diff2];
            return { type: 'Alternating', sequence, answer: start1 + 2 * diff1 };
        }
    };

    // --- Event Handlers ---
    startGameBtn.addEventListener('click', startGame);
    backToGamesBtn.addEventListener('click', quitGame);
    returnToGamesFinalBtn.addEventListener('click', () => window.location.href = gameBody.dataset.gameListUrl);

    // --- Game Flow Functions ---
    function startGame() {
        instructionModal.style.display = 'none';
        gameInProgress = true;
        currentRound = 0;
        score = 0;
        difficulty = 1;
        gameEvents = [];
        startTimer();
        nextRound();
    }

    function nextRound() {
        if (currentRound >= TOTAL_ROUNDS) {
            endGame();
            return;
        }
        currentRound++;
        updateDashboard();
        const pattern = generatePattern();
        renderPattern(pattern);
        roundStartTime = Date.now();
    }

    function generatePattern() {
        const availableLevels = Object.keys(patternGenerators).filter(level => level <= difficulty);
        const randomLevel = availableLevels[Math.floor(Math.random() * availableLevels.length)];
        const { type, sequence, answer } = patternGenerators[randomLevel]();

        const options = new Set([answer]);
        while (options.size < 4) {
            const deviation = Math.floor(Math.random() * 10) + 1;
            const wrongAnswer = answer + (Math.random() > 0.5 ? deviation : -deviation);
            if (wrongAnswer > 0) options.add(wrongAnswer);
        }
        const shuffledOptions = Array.from(options).sort(() => Math.random() - 0.5);
        return { type, sequence, answer, options: shuffledOptions };
    }

    function handleAnswer(selectedAnswer, correctAnswer, sequence, type) {
        const reactionTime = Date.now() - roundStartTime;
        const isCorrect = selectedAnswer === correctAnswer;

        const roundScore = isCorrect ? Math.max(0, BASE_SCORE_PER_ROUND - Math.floor(reactionTime / 1000) * TIME_PENALTY_FACTOR) : 0;
        score += roundScore;

        logEvent('answer_selected', {
            round: currentRound,
            sequence, type,
            selectedAnswer, correctAnswer, isCorrect,
            reactionTime, roundScore
        });

        if (isCorrect) {
            difficulty = Math.min(5, difficulty + 0.5);
        } else {
            difficulty = Math.max(1, difficulty - 1);
        }

        updateDashboard();
        visualFeedback(isCorrect, selectedAnswer);

        setTimeout(nextRound, 1000);
    }

    function endGame() {
        gameInProgress = false;
        stopTimer();
        logEvent('game_completed');
        showFinalResults();
        sendEventsToBackend('completed');
    }

    function quitGame() {
        if (!gameInProgress) {
            window.location.href = gameBody.dataset.gameListUrl;
            return;
        }
        gameInProgress = false;
        stopTimer();
        logEvent('game_quit');
        sendEventsToBackend('abandoned').finally(() => {
            window.location.href = gameBody.dataset.gameListUrl;
        });
    }

    // --- UI & Rendering ---
    function updateDashboard() {
        roundDisplay.textContent = `${currentRound}/${TOTAL_ROUNDS}`;
        scoreDisplay.textContent = score;
        difficultyDisplay.textContent = parseFloat(difficulty).toFixed(1);
    }

    function renderPattern({ type, sequence, answer, options }) {
        patternDisplay.innerHTML = sequence.map(num => `<div class="pattern-item">${num}</div>`).join('') + '<div class="pattern-item question-mark">?</div>';
        optionsContainer.innerHTML = options.map(opt => `<button class="option-btn" data-answer="${opt}">${opt}</button>`).join('');

        optionsContainer.querySelectorAll('.option-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Disable buttons after one is clicked
                optionsContainer.querySelectorAll('.option-btn').forEach(b => b.disabled = true);
                handleAnswer(parseInt(btn.dataset.answer), answer, sequence, type);
            });
        });
    }

    function visualFeedback(isCorrect, selectedAnswer) {
        const selectedBtn = optionsContainer.querySelector(`[data-answer="${selectedAnswer}"]`);
        if (selectedBtn) {
            selectedBtn.classList.add(isCorrect ? 'correct' : 'incorrect');
        }
    }

    function showFinalResults() {
        const correctAnswers = gameEvents.filter(e => e.details.isCorrect).length;
        const avgReactionTime = gameEvents.length > 0 ? (gameEvents.reduce((acc, e) => acc + (e.details.reactionTime || 0), 0) / correctAnswers).toFixed(0) : 0;

        finalSummary.innerHTML = `
            <div><strong>Final Score:</strong></div><div>${score}</div>
            <div><strong>Rounds Completed:</strong></div><div>${currentRound}/${TOTAL_ROUNDS}</div>
            <div><strong>Accuracy:</strong></div><div>${((correctAnswers / currentRound) * 100).toFixed(1)}%</div>
            <div><strong>Avg. Correct RT:</strong></div><div>${avgReactionTime} ms</div>
        `;
        finalResultsModal.style.display = 'flex';
    }

    function startTimer() {
        let seconds = 0;
        timerDisplay.textContent = '0s';
        gameTimerInterval = setInterval(() => {
            seconds++;
            timerDisplay.textContent = `${seconds}s`;
        }, 1000);
    }

    function stopTimer() {
        clearInterval(gameTimerInterval);
    }

    // --- Data & Backend ---
    function logEvent(type, details = {}) {
        gameEvents.push({ timestamp: Date.now(), type, details });
        console.log(`Event: ${type}`, details);
    }

    function sendEventsToBackend(completionStatus) {
        const payload = {
            game_name: 'pattern_completion',
            score: score,
            completion_status: completionStatus,
            events: gameEvents,
            game_specific_data: {
                final_difficulty: difficulty,
                total_rounds_completed: currentRound
            }
        };

        return fetch('/games/save-score/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': gameBody.dataset.csrfToken
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (data.status !== 'success') {
                console.error('Backend Error:', data.message);
            }
        })
        .catch(error => console.error('Failed to save game data:', error));
    }
});
</script>
{% endblock %}
