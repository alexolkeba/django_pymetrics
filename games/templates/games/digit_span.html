{% extends 'base.html' %}
{% load static %}
{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
    :root {
        --primary-color: #6366F1; /* Indigo 500 */
        --success-color: #34D399; /* Green 400 */
        --danger-color: #F87171; /* Red 400 */
        --background-color: #0F172A; /* Slate 900 */
        --surface-color: #1E293B; /* Slate 800 */
        --text-color: #F1F5F9; /* Slate 100 */
        --muted-text-color: #94A3B8; /* Slate 400 */
        --border-color: #334155; /* Slate 700 */
    }
    .game-body { background-color: var(--background-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 1rem; }
    .game-container { background-color: var(--surface-color); border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); width: 100%; max-width: 600px; overflow: hidden; }
    .game-header { background-color: rgba(0,0,0,0.2); padding: 1.5rem; text-align: center; border-bottom: 1px solid var(--border-color); }
    .game-header h2 { font-size: 1.75rem; font-weight: bold; margin: 0; }
    .dashboard { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; padding: 1.5rem; border-bottom: 1px solid var(--border-color); }
    .stat-card { background-color: rgba(0,0,0,0.2); padding: 1rem; border-radius: 8px; text-align: center; }
    .stat-card .value { font-size: 1.75rem; font-weight: bold; color: var(--primary-color); }
    .stat-card .label { font-size: 0.8rem; color: var(--muted-text-color); text-transform: uppercase; font-weight: 600; }
    .game-area { padding: 2rem; min-height: 350px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
    #sequence-display { font-size: 3.5rem; font-weight: bold; letter-spacing: 0.5rem; height: 60px; margin-bottom: 1rem; }
    #input-area { width: 100%; max-width: 300px; }
    #user-input { background-color: #0F172A; border: 2px solid var(--border-color); color: var(--text-color); font-size: 2rem; text-align: center; width: 100%; border-radius: 8px; padding: 0.5rem; margin-bottom: 1rem; }
    .numpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; }
    .numpad button { background-color: var(--surface-color); border: 1px solid var(--border-color); color: var(--text-color); font-size: 1.5rem; padding: 1rem; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
    .numpad button:hover { background-color: var(--primary-color); }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
    .modal-content { background-color: var(--surface-color); padding: 2.5rem; border-radius: 12px; border: 1px solid var(--border-color); max-width: 500px; width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.5); animation: modal-pop 0.3s ease-out; text-align: center; }
    @keyframes modal-pop { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    #back-to-games-btn { position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.3); color: var(--text-color); padding: 0.5rem 1rem; border-radius: 8px; text-decoration: none; font-weight: bold; z-index: 10; }
</style>

<div class="game-body" data-game-list-url="{% url 'games:game_list' %}" data-csrf-token="{{ csrf_token }}">
    <a href="#" id="back-to-games-btn"><i class="fas fa-arrow-left"></i> Back to Games</a>

    <div class="game-container">
        <div class="game-header"><h2>Working Memory Challenge</h2></div>
        <div class="dashboard">
            <div class="stat-card"><div id="task-type" class="value">-</div><div class="label">Task</div></div>
            <div class="stat-card"><div id="current-span" class="value">-</div><div class="label">Current Span</div></div>
            <div class="stat-card"><div id="max-span" class="value">-</div><div class="label">Max Span</div></div>
        </div>

        <div class="game-area">
            <div id="sequence-display"></div>
            <div id="input-area" style="display: none;">
                <input type="text" id="user-input" readonly>
                <div class="numpad"></div>
                <button id="submit-btn" class="btn" style="width: 100%; margin-top: 1rem; background-color: var(--success-color);">Submit</button>
            </div>
            <p id="feedback-text" style="height: 20px; margin-top: 1rem; font-weight: bold;"></p>
        </div>
    </div>

    <!-- Modals -->
    <div id="instruction-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h3 style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">Welcome to the Working Memory Challenge!</h3>
            <p style="margin: 1rem 0;">You will be tested on two tasks: <strong>Forward Span</strong> and <strong>Backward Span</strong>. A sequence of numbers will appear. Your goal is to recall them in the correct order. The sequence length will increase as you succeed. The challenge ends after two incorrect attempts on any given length.</p>
            <button id="start-game-btn" class="btn">Start Challenge</button>
        </div>
    </div>
    <div id="final-results-modal" class="modal">
        <div class="modal-content">
            <h3 style="font-size: 1.5rem; font-weight: bold;">Challenge Complete!</h3>
            <div id="final-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem 1rem; text-align: left; margin: 1.5rem auto; width: fit-content;"></div>
            <button id="return-to-games-final-btn" class="btn">Return to Games</button>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- CONFIGURATION ---
    const GAME_ID = 'digit_span';
    const STARTING_SPAN = 3;
    const MAX_INCORRECT_STREAK = 2;
    const PRESENTATION_SPEED_MS = 1000;
    const FEEDBACK_DELAY_MS = 1500;

    // --- DOM Elements ---
    const gameBody = document.querySelector('.game-body');
    const { instructionModal, finalResultsModal, sequenceDisplay, inputArea, userInput, numpad, submitBtn, feedbackText } = {
        instructionModal: document.getElementById('instruction-modal'),
        finalResultsModal: document.getElementById('final-results-modal'),
        sequenceDisplay: document.getElementById('sequence-display'),
        inputArea: document.getElementById('input-area'),
        userInput: document.getElementById('user-input'),
        numpad: document.getElementById('numpad'),
        submitBtn: document.getElementById('submit-btn'),
        feedbackText: document.getElementById('feedback-text'),
    };
    const { taskTypeEl, currentSpanEl, maxSpanEl } = {
        taskTypeEl: document.getElementById('task-type'),
        currentSpanEl: document.getElementById('current-span'),
        maxSpanEl: document.getElementById('max-span'),
    };
    const { startGameBtn, backToGamesBtn, returnToGamesFinalBtn } = {
        startGameBtn: document.getElementById('start-game-btn'),
        backToGamesBtn: document.getElementById('back-to-games-btn'),
        returnToGamesFinalBtn: document.getElementById('return-to-games-final-btn'),
    };

    // --- GAME STATE ---
    let state = {};
    const resetState = () => {
        state = {
            gameStartTime: 0,
            currentSpan: STARTING_SPAN,
            maxForwardSpan: 0,
            maxBackwardSpan: 0,
            taskType: 'forward', // or 'backward'
            incorrectStreak: 0,
            currentSequence: [],
            events: [],
            gameCompleted: false,
            isSaving: false,
        };
    };

    // --- Core Game Logic ---
    const startGame = async () => {
        resetState();
        setupNumpad();
        state.gameStartTime = Date.now();
        instructionModal.style.display = 'none';
        logEvent('game_start');
        await nextTrial();
    };

    const nextTrial = async () => {
        if (state.incorrectStreak >= MAX_INCORRECT_STREAK) {
            if (state.taskType === 'forward') {
                state.taskType = 'backward';
                state.currentSpan = STARTING_SPAN;
                state.incorrectStreak = 0;
                logEvent('task_switch', { new_task: 'backward' });
                feedbackText.textContent = 'Next up: Backward Span!';
                updateDashboard();
                await new Promise(resolve => setTimeout(resolve, FEEDBACK_DELAY_MS * 1.5));
                await nextTrial();
                return;
            } else {
                await endGame(true);
                return;
            }
        }

        inputArea.style.display = 'none';
        userInput.value = '';
        feedbackText.textContent = '';
        updateDashboard();

        state.currentSequence = generateSequence(state.currentSpan);
        state.trialStartTime = Date.now();
        logEvent('trial_start', { task: state.taskType, span: state.currentSpan, sequence: state.currentSequence });
        presentSequence();
    };

    const generateSequence = (length) => {
        let seq = '';
        for (let i = 0; i < length; i++) {
            seq += Math.floor(Math.random() * 10);
        }
        return seq;
    };

    const presentSequence = async () => {
        for (const digit of state.currentSequence) {
            sequenceDisplay.textContent = digit;
            await new Promise(resolve => setTimeout(resolve, PRESENTATION_SPEED_MS));
            sequenceDisplay.textContent = '';
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        sequenceDisplay.textContent = '';
        promptForInput();
    };

    const promptForInput = () => {
        feedbackText.textContent = `Recall the sequence in ${state.taskType} order.`;
        inputArea.style.display = 'block';
    };

    const handleSubmit = () => {
        const reactionTime = Date.now() - state.trialStartTime;
        const userResponse = userInput.value;
        const correctResponse = state.taskType === 'forward' ? state.currentSequence : state.currentSequence.split('').reverse().join('');
        const isCorrect = userResponse === correctResponse;

        logEvent('trial_end', { response: userResponse, correct_response: correctResponse, is_correct: isCorrect, reaction_time: reactionTime });

        if (isCorrect) {
            feedbackText.textContent = 'Correct!';
            feedbackText.style.color = 'var(--success-color)';
            state.incorrectStreak = 0;
            if (state.taskType === 'forward') state.maxForwardSpan = Math.max(state.maxForwardSpan, state.currentSpan);
            else state.maxBackwardSpan = Math.max(state.maxBackwardSpan, state.currentSpan);
            state.currentSpan++;
        } else {
            feedbackText.textContent = 'Incorrect.';
            feedbackText.style.color = 'var(--danger-color)';
            state.incorrectStreak++;
        }
        
        setTimeout(() => nextTrial(), FEEDBACK_DELAY_MS);
    };

    const endGame = async (completed) => {
        state.gameCompleted = completed;
        logEvent('game_end', { completed });
        displayFinalResults();
        finalResultsModal.style.display = 'flex';
        await sendDataToBackend();
    };

    // --- UI & Helpers ---
    const setupNumpad = () => {
        numpad.innerHTML = '';
        for (let i = 1; i <= 9; i++) {
            const btn = document.createElement('button');
            btn.textContent = i;
            btn.addEventListener('click', () => userInput.value += i);
            numpad.appendChild(btn);
        }
        const clearBtn = document.createElement('button');
        clearBtn.innerHTML = '&larr;';
        clearBtn.addEventListener('click', () => userInput.value = userInput.value.slice(0, -1));
        numpad.appendChild(clearBtn);
        const zeroBtn = document.createElement('button');
        zeroBtn.textContent = '0';
        zeroBtn.addEventListener('click', () => userInput.value += '0');
        numpad.appendChild(zeroBtn);
    };

    const updateDashboard = () => {
        taskTypeEl.textContent = state.taskType.charAt(0).toUpperCase() + state.taskType.slice(1);
        currentSpanEl.textContent = state.currentSpan;
        const maxSpan = state.taskType === 'forward' ? state.maxForwardSpan : state.maxBackwardSpan;
        maxSpanEl.textContent = maxSpan > 0 ? maxSpan : '-';
    };

    const displayFinalResults = () => {
        document.getElementById('final-summary').innerHTML = `
            <div><strong>Max Forward Span:</strong></div><div style="color: var(--primary-color); font-weight: bold;">${state.maxForwardSpan}</div>
            <div><strong>Max Backward Span:</strong></div><div style="color: var(--primary-color); font-weight: bold;">${state.maxBackwardSpan}</div>
        `;
    };

    // --- Data Handling ---
    const logEvent = (type, details = {}) => {
        state.events.push({ type, timestamp: Date.now() - state.gameStartTime, ...details });
    };

    const sendDataToBackend = async () => {
        if (state.isSaving) return;
        state.isSaving = true;

        try {
            const completionStatus = state.gameCompleted ? 'completed' : 'abandoned';
            const score = state.maxForwardSpan + state.maxBackwardSpan;
            const data = {
                game_name: GAME_ID,
                score: score,
                duration_ms: Date.now() - state.gameStartTime,
                completion_status: completionStatus,
                events: state.events,
                game_specific_data: { max_forward_span: state.maxForwardSpan, max_backward_span: state.maxBackwardSpan }
            };

            const response = await fetch('{% url "games:save_score" %}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': gameBody.dataset.csrfToken },
                body: JSON.stringify(data),
            });

            if (!response.ok) throw new Error('Server error');
            return await response.json();
        } catch (error) {
            console.error('Error saving data:', error);
        } finally {
            state.isSaving = false;
        }
    };

    const quitGame = async () => {
        if (state.isSaving || state.gameStartTime === 0) return;
        state.gameCompleted = false;
        await sendDataToBackend();
    };

    // --- Event Listeners ---
    const handleExit = async (e) => {
        e.preventDefault();
        if (state.isSaving) return;

        if (state.gameStartTime !== 0 && !state.gameCompleted) {
            await quitGame();
        }

        window.location.href = gameBody.dataset.gameListUrl;
    };

    startGameBtn.addEventListener('click', startGame);
    submitBtn.addEventListener('click', handleSubmit);
    backToGamesBtn.addEventListener('click', handleExit);
    returnToGamesFinalBtn.addEventListener('click', handleExit);
});
</script>
{% endblock %}
