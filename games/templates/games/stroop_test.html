{% extends 'base.html' %}
{% load static %}
{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
    :root {
        --primary-color: #EC4899; /* Pink for engagement */
        --secondary-color: #10B981;
        --background-color: #111827;
        --surface-color: #1F2937;
        --text-color: #F9FAFB;
        --muted-text-color: #9CA3AF;
        --border-color: #374151;
        --correct-color: #10B981;
        --incorrect-color: #EF4444;
    }
    .game-body { background-color: var(--background-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 1rem; }
    .game-container { background-color: var(--surface-color); border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); width: 100%; max-width: 900px; overflow: hidden; }
    .game-header { background-color: rgba(0,0,0,0.2); padding: 1.5rem; text-align: center; border-bottom: 1px solid var(--border-color); }
    .game-header h2 { font-size: 1.75rem; font-weight: bold; margin: 0; }
    .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 1rem; padding: 1.5rem; border-bottom: 1px solid var(--border-color); }
    .stat-card { background-color: #374151; padding: 1rem; border-radius: 8px; text-align: center; }
    .stat-card .value { font-size: 1.5rem; font-weight: bold; color: var(--primary-color); }
    .stat-card .label { font-size: 0.8rem; color: var(--muted-text-color); text-transform: uppercase; }
    .game-area { padding: 2rem; min-height: 400px; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; }
    #stimulus-word { font-size: 6rem; font-weight: bold; text-transform: uppercase; transition: transform 0.2s; }
    .color-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 3rem; width: 100%; max-width: 600px; }
    .color-btn { padding: 1rem 2rem; border: 2px solid var(--border-color); border-radius: 8px; font-size: 1.25rem; font-weight: bold; cursor: pointer; transition: all 0.2s; background-color: transparent; color: var(--text-color); }
    .color-btn:hover { border-color: var(--primary-color); color: var(--primary-color); transform: translateY(-3px); }
    .feedback-indicator { font-size: 3rem; margin-top: 2rem; height: 60px; }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
    .modal-content { background-color: var(--surface-color); padding: 2rem; border-radius: 12px; border: 1px solid var(--border-color); max-width: 500px; width: 90%; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.5); animation: modal-pop 0.3s ease-out; }
    @keyframes modal-pop { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s; color: white; background-color: var(--primary-color); }
    .btn:hover { background-color: #D946EF; }
    #back-to-games { position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.3); color: var(--text-color); padding: 0.5rem 1rem; border-radius: 8px; text-decoration: none; font-weight: bold; z-index: 10; }
    #timer-bar-container { width: 80%; max-width: 500px; height: 10px; background-color: #374151; border-radius: 5px; position: absolute; top: 20px; }
    #timer-bar { width: 100%; height: 100%; background-color: var(--primary-color); border-radius: 5px; transition: width 0.1s linear; }
</style>

<div class="game-body" data-game-list-url="{% url 'games:game_list' %}">
    <a href="#" id="back-to-games"><i class="fas fa-arrow-left"></i> Back to Games</a>

    <div class="game-container">
        <div class="game-header">
            <h2 id="game-title">Cognitive Control Challenge</h2>
        </div>

        <div class="dashboard">
            <div class="stat-card"><div id="trial-display" class="value">0 / 40</div><div class="label">Trial</div></div>
            <div class="stat-card"><div id="correct-display" class="value">0</div><div class="label">Correct</div></div>
            <div class="stat-card"><div id="incorrect-display" class="value">0</div><div class="label">Incorrect</div></div>
            <div class="stat-card"><div id="accuracy-display" class="value">100%</div><div class="label">Accuracy</div></div>
            <div class="stat-card"><div id="avg-rt-display" class="value">-</div><div class="label">Avg. RT (ms)</div></div>
        </div>

        <div class="game-area">
            <div id="timer-bar-container"> <div id="timer-bar"></div> </div>
            <div id="stimulus-word"></div>
            <div id="feedback-indicator" class="feedback-indicator"></div>
            <div id="color-buttons" class="color-buttons"></div>
        </div>
    </div>

    <!-- Modals -->
    <div id="instruction-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h3>Welcome to the Cognitive Control Challenge!</h3>
            <p>Your task is to identify the FONT COLOR of the word, not the word itself. Respond as quickly and accurately as possible. The time you have to answer will adapt based on your performance.</p>
            <button id="start-game-btn" class="btn">Start Congruent Block</button>
        </div>
    </div>
    <div id="break-modal" class="modal">
        <div class="modal-content">
            <h3>Block Complete!</h3>
            <p>Great job! Now for the real challenge. The words will now conflict with their colors. Remember to focus only on the FONT COLOR.</p>
            <button id="start-incongruent-btn" class="btn">Start Incongruent Block</button>
        </div>
    </div>
    <div id="final-results-modal" class="modal">
        <div class="modal-content">
            <h3>Challenge Complete!</h3>
            <div id="final-summary" style="text-align: left; margin: 1rem 0;"></div>
            <button id="return-to-games-btn" class="btn">Back to Games</button>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- CONFIGURATION ---
    const GAME_LIST_URL = document.querySelector('.game-body').dataset.gameListUrl;
    const TRIALS_PER_BLOCK = 20;
    const COLORS = {
        'red': '#F87171', 'green': '#34D399', 'blue': '#60A5FA',
        'yellow': '#FBBF24', 'purple': '#A78BFA', 'orange': '#F97316'
    };
    const INITIAL_TIME_LIMIT = 2000; // ms
    const MIN_TIME_LIMIT = 500;
    const MAX_TIME_LIMIT = 4000;
    const TIME_ADJUSTMENT_CORRECT = 50; // ms to decrease
    const TIME_ADJUSTMENT_INCORRECT = 100; // ms to increase

    // --- DOM ELEMENTS ---
    const stimulusWord = document.getElementById('stimulus-word');
    const colorButtonsContainer = document.getElementById('color-buttons');
    const feedbackIndicator = document.getElementById('feedback-indicator');
    const instructionModal = document.getElementById('instruction-modal');
    const breakModal = document.getElementById('break-modal');
    const finalResultsModal = document.getElementById('final-results-modal');
    const startGameBtn = document.getElementById('start-game-btn');
    const startIncongruentBtn = document.getElementById('start-incongruent-btn');
    const returnToGamesBtn = document.getElementById('return-to-games-btn');
    const backToGamesBtn = document.getElementById('back-to-games');
    const timerBar = document.getElementById('timer-bar');

    const trialDisplay = document.getElementById('trial-display');
    const correctDisplay = document.getElementById('correct-display');
    const incorrectDisplay = document.getElementById('incorrect-display');
    const accuracyDisplay = document.getElementById('accuracy-display');
    const avgRtDisplay = document.getElementById('avg-rt-display');

    // --- GAME STATE ---
    let gameState = 'instructions';
    let totalTrialCount = 0;
    let blockTrialCount = 0;
    let correctCount = 0;
    let incorrectCount = 0;
    let congruentRTs = [];
    let incongruentRTs = [];
    let adaptiveTimeLimit = INITIAL_TIME_LIMIT;
    let trialStartTime;
    let trialTimerInterval;
    let events = [];
    let gameStartTime;
    let gameCompleted = false;
    let isSaving = false;

    // --- FUNCTIONS ---
    const showModal = (modal) => modal.style.display = 'flex';
    const hideModal = (modal) => modal.style.display = 'none';

    const updateDashboard = () => {
        const totalTrials = correctCount + incorrectCount;
        const accuracy = totalTrials > 0 ? Math.round((correctCount / totalTrials) * 100) : 100;
        const allRTs = [...congruentRTs, ...incongruentRTs];
        const avgRT = allRTs.length > 0 ? Math.round(allRTs.reduce((a, b) => a + b, 0) / allRTs.length) : '-';
        trialDisplay.textContent = `${totalTrialCount} / ${TRIALS_PER_BLOCK * 2}`;
        correctDisplay.textContent = correctCount;
        incorrectDisplay.textContent = incorrectCount;
        accuracyDisplay.textContent = `${accuracy}%`;
        avgRtDisplay.textContent = avgRT;
    };

    const startTrialTimer = () => {
        let timeLeft = adaptiveTimeLimit;
        timerBar.style.transition = 'none';
        timerBar.style.width = '100%';
        setTimeout(() => {
            timerBar.style.transition = `width ${adaptiveTimeLimit / 1000}s linear`;
            timerBar.style.width = '0%';
        }, 20);
        trialTimerInterval = setTimeout(() => handleResponse(null, null, 'timeout'), adaptiveTimeLimit);
    };

    const generateTrial = () => {
        const colorNames = Object.keys(COLORS);
        const randomColorName = colorNames[Math.floor(Math.random() * colorNames.length)];
        const randomColorHex = COLORS[randomColorName];
        let randomWord;
        if (gameState === 'congruent') {
            randomWord = randomColorName;
        } else { // incongruent
            let otherWords = colorNames.filter(name => name !== randomColorName);
            randomWord = otherWords[Math.floor(Math.random() * otherWords.length)];
        }
        return { word: randomWord, colorName: randomColorName, colorHex: randomColorHex };
    };

    const presentTrial = () => {
        colorButtonsContainer.innerHTML = '';
        feedbackIndicator.textContent = '';
        const trial = generateTrial();
        stimulusWord.textContent = trial.word;
        stimulusWord.style.color = trial.colorHex;

        Object.keys(COLORS).forEach(colorName => {
            const btn = document.createElement('button');
            btn.className = 'color-btn';
            btn.textContent = colorName;
            btn.style.borderColor = COLORS[colorName];
            btn.onclick = () => handleResponse(colorName, trial);
            colorButtonsContainer.appendChild(btn);
        });
        trialStartTime = Date.now();
        startTrialTimer();
    };

    const handleResponse = (selectedColorName, trial, status) => {
        clearTimeout(trialTimerInterval);
        const reactionTime = Date.now() - trialStartTime;
        let isCorrect = false;

        if (status === 'timeout') {
            feedbackIndicator.textContent = '⌛';
            feedbackIndicator.style.color = 'orange';
            incorrectCount++;
            adaptiveTimeLimit = Math.min(MAX_TIME_LIMIT, adaptiveTimeLimit + TIME_ADJUSTMENT_INCORRECT);
        } else {
            isCorrect = selectedColorName === trial.colorName;
            if (isCorrect) {
                feedbackIndicator.textContent = '✓';
                feedbackIndicator.style.color = '#10B981';
                correctCount++;
                adaptiveTimeLimit = Math.max(MIN_TIME_LIMIT, adaptiveTimeLimit - TIME_ADJUSTMENT_CORRECT);
                if (gameState === 'congruent') congruentRTs.push(reactionTime); else incongruentRTs.push(reactionTime);
            } else {
                feedbackIndicator.textContent = '✗';
                feedbackIndicator.style.color = '#EF4444';
                incorrectCount++;
                adaptiveTimeLimit = Math.min(MAX_TIME_LIMIT, adaptiveTimeLimit + TIME_ADJUSTMENT_INCORRECT);
            }
        }

        events.push({ 
            event_type: 'response', trial: totalTrialCount + 1, condition: gameState, 
            is_correct: isCorrect, rt: reactionTime, status: status || 'answered',
            stimulus: trial, response: selectedColorName, time_limit: adaptiveTimeLimit,
            timestamp: Date.now() - gameStartTime
        });

        totalTrialCount++;
        blockTrialCount++;
        updateDashboard();
        colorButtonsContainer.innerHTML = '<p style="font-size: 1.5rem;">...</p>';

        setTimeout(() => {
            if (blockTrialCount < TRIALS_PER_BLOCK) {
                presentTrial();
            } else {
                if (gameState === 'congruent') {
                    gameState = 'break';
                    blockTrialCount = 0;
                    showModal(breakModal);
                } else if (gameState === 'incongruent') {
                    endGame();
                }
            }
        }, 1200);
    };

    const startGame = () => {
        gameState = 'congruent';
        gameStartTime = Date.now();
        events.push({ event_type: 'game_start', timestamp: 0 });
        hideModal(instructionModal);
        presentTrial();
    };

    const startIncongruentBlock = () => {
        gameState = 'incongruent';
        hideModal(breakModal);
        presentTrial();
    };

    const endGame = async () => {
        if (gameCompleted) return; // Prevent multiple calls
        gameState = 'finished';
        gameCompleted = true;
        events.push({ event_type: 'game_end', timestamp: Date.now() - gameStartTime });

        // Ensure data is saved before showing final results and allowing exit.
        await sendDataToBackend();

        displayFinalResults();
        showModal(finalResultsModal);
    };

    const displayFinalResults = () => {
        const summaryContainer = document.getElementById('final-summary');
        const avgCongruentRT = congruentRTs.length > 0 ? Math.round(congruentRTs.reduce((a, b) => a + b, 0) / congruentRTs.length) : 0;
        const avgIncongruentRT = incongruentRTs.length > 0 ? Math.round(incongruentRTs.reduce((a, b) => a + b, 0) / incongruentRTs.length) : 0;
        const stroopEffect = avgIncongruentRT - avgCongruentRT;

        summaryContainer.innerHTML = `
            <p><strong>Accuracy:</strong> ${accuracyDisplay.textContent}</p>
            <p><strong>Avg. Congruent RT:</strong> ${avgCongruentRT} ms</p>
            <p><strong>Avg. Incongruent RT:</strong> ${avgIncongruentRT} ms</p>
            <p><strong>Stroop Interference:</strong> ${stroopEffect} ms</p>
            <p><strong>Final Time Limit:</strong> ${adaptiveTimeLimit} ms</p>
        `;
    };

    async function sendDataToBackend() {
        if (isSaving || !gameStartTime) return;
        isSaving = true;

        const completionStatus = gameCompleted ? 'completed' : 'abandoned';
        const totalDuration = Date.now() - gameStartTime;
        const score = correctCount * 10 - incorrectCount * 5; // Example scoring
        const avgCongruentRT = congruentRTs.length > 0 ? Math.round(congruentRTs.reduce((a, b) => a + b, 0) / congruentRTs.length) : 0;
        const avgIncongruentRT = incongruentRTs.length > 0 ? Math.round(incongruentRTs.reduce((a, b) => a + b, 0) / incongruentRTs.length) : 0;

        const payload = {
            game_name: 'stroop_test',
            score: Math.max(0, score),
            duration_ms: totalDuration,
            completion_status: completionStatus,
            events: events,
            game_specific_data: {
                correct_count: correctCount,
                incorrect_count: incorrectCount,
                accuracy: (correctCount + incorrectCount) > 0 ? correctCount / (correctCount + incorrectCount) : 0,
                avg_congruent_rt: avgCongruentRT,
                avg_incongruent_rt: avgIncongruentRT,
                stroop_effect: avgIncongruentRT - avgCongruentRT,
                final_time_limit: adaptiveTimeLimit
            }
        };

        try {
            const response = await fetch('{% url "games:save_score" %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error('Server error during save.');
        } catch (err) {
            console.error('Error saving game data:', err);
        } finally {
            isSaving = false;
        }
    }

    // --- EVENT LISTENERS ---
    startGameBtn.addEventListener('click', startGame);
    startIncongruentBtn.addEventListener('click', startIncongruentBlock);
    
    const handleExit = async (e) => {
        e.preventDefault();
        if (isSaving) return; // Prevent multiple clicks

        // If game is in progress, mark as abandoned and save.
        if (gameState !== 'finished' && gameStartTime) {
            gameCompleted = false;
            await sendDataToBackend();
        }

        // Redirect only after saving is complete (or if no save was needed).
        window.location.href = GAME_LIST_URL;
    };

    returnToGamesBtn.addEventListener('click', handleExit);
    backToGamesBtn.addEventListener('click', handleExit);
});
</script>
{% endblock %}
