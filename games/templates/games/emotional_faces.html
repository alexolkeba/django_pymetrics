{% extends 'base.html' %}
{% load static %}
{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
    :root {
        --primary-color: #F472B6; /* Pink 400 */
        --success-color: #34D399; /* Green 400 */
        --danger-color: #F87171; /* Red 400 */
        --background-color: #0F172A; /* Slate 900 */
        --surface-color: #1E293B; /* Slate 800 */
        --text-color: #F1F5F9; /* Slate 100 */
        --muted-text-color: #94A3B8; /* Slate 400 */
        --border-color: #334155; /* Slate 700 */
    }
    .game-body { background-color: var(--background-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 1rem; }
    .game-container { background-color: var(--surface-color); border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); width: 100%; max-width: 700px; overflow: hidden; }
    .game-header { background-color: rgba(0,0,0,0.2); padding: 1.5rem; text-align: center; border-bottom: 1px solid var(--border-color); }
    .game-header h2 { font-size: 1.75rem; font-weight: bold; margin: 0; }
    .dashboard { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; padding: 1.5rem; border-bottom: 1px solid var(--border-color); }
    .stat-card { background-color: rgba(0,0,0,0.2); padding: 1rem; border-radius: 8px; text-align: center; }
    .stat-card .value { font-size: 1.75rem; font-weight: bold; color: var(--primary-color); }
    .stat-card .label { font-size: 0.8rem; color: var(--muted-text-color); text-transform: uppercase; font-weight: 600; }
    .game-area { padding: 2rem; min-height: 450px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
    #face-image { width: 250px; height: 250px; border-radius: 12px; border: 3px solid var(--border-color); margin-bottom: 2rem; object-fit: cover; }
    .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; width: 100%; max-width: 500px; }
    .option-btn { background-color: var(--surface-color); border: 1px solid var(--border-color); color: var(--text-color); padding: 1rem; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; }
    .option-btn:hover { background-color: var(--primary-color); border-color: var(--primary-color); }
    .feedback { font-size: 1.25rem; font-weight: bold; margin-top: 1.5rem; height: 25px; }
    .correct { color: var(--success-color); }
    .incorrect { color: var(--danger-color); }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
    .modal-content { background-color: var(--surface-color); padding: 2.5rem; border-radius: 12px; border: 1px solid var(--border-color); max-width: 500px; width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.5); animation: modal-pop 0.3s ease-out; text-align: center; }
    @keyframes modal-pop { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    #back-to-games-btn { position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.3); color: var(--text-color); padding: 0.5rem 1rem; border-radius: 8px; text-decoration: none; font-weight: bold; z-index: 10; }
</style>

<div class="game-body" data-game-list-url="{% url 'games:game_list' %}" data-csrf-token="{{ csrf_token }}">
    <a href="#" id="back-to-games-btn"><i class="fas fa-arrow-left"></i> Back to Games</a>

    <div class="game-container">
        <div class="game-header"><h2>Facial Emotion Perception</h2></div>
        <div class="dashboard">
            <div class="stat-card"><div id="accuracy" class="value">100%</div><div class="label">Accuracy</div></div>
            <div class="stat-card"><div id="trial-counter" class="value">-</div><div class="label">Trial</div></div>
        </div>

        <div class="game-area">
            <img id="face-image" src="" alt="Facial Expression">
            <div id="options-container" class="options-grid"></div>
            <div id="feedback" class="feedback"></div>
        </div>
    </div>

    <!-- Modals -->
    <div id="instruction-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h3 style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">Welcome to the Facial Emotion Perception Task!</h3>
            <p style="margin: 1rem 0;">You will be shown a series of faces, each displaying an emotion. Your task is to identify the correct emotion from the options provided. The challenge consists of 24 trials. Good luck!</p>
            <button id="start-game-btn" class="btn">Start Task</button>
        </div>
    </div>
    <div id="final-results-modal" class="modal">
        <div class="modal-content">
            <h3 style="font-size: 1.5rem; font-weight: bold;">Task Complete!</h3>
            <div id="final-summary" style="margin: 1.5rem 0;"></div>
            <button id="return-to-games-final-btn" class="btn">Return to Games</button>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- CONFIGURATION ---
    const GAME_ID = 'emotional_faces';
    const TOTAL_TRIALS = 24;
    const EMOTIONS = ['happy', 'sad', 'angry', 'fear', 'surprise', 'disgust'];
    // Assumes images are named like 'happy_01.jpg', 'sad_02.jpg' etc.
    const IMAGE_COUNT_PER_EMOTION = 4;
    const STATIC_IMG_PATH = "{% static 'games/images/emotional_faces/' %}";

    // --- DOM Elements ---
    const gameBody = document.querySelector('.game-body');
    const { instructionModal, finalResultsModal, faceImage, optionsContainer, feedbackEl } = {
        instructionModal: document.getElementById('instruction-modal'),
        finalResultsModal: document.getElementById('final-results-modal'),
        faceImage: document.getElementById('face-image'),
        optionsContainer: document.getElementById('options-container'),
        feedbackEl: document.getElementById('feedback'),
    };
    const { accuracyEl, trialCounterEl } = {
        accuracyEl: document.getElementById('accuracy'),
        trialCounterEl: document.getElementById('trial-counter'),
    };
    const { startGameBtn, backToGamesBtn, returnToGamesFinalBtn } = {
        startGameBtn: document.getElementById('start-game-btn'),
        backToGamesBtn: document.getElementById('back-to-games-btn'),
        returnToGamesFinalBtn: document.getElementById('return-to-games-final-btn'),
    };

    // --- GAME STATE ---
    let state = {};
    const resetState = () => {
        state = {
            currentTrial: 0,
            correctCount: 0,
            trialList: [],
            events: [],
            gameStartTime: 0,
            trialStartTime: 0,
            gameCompleted: false,
            currentCorrectEmotion: '',
        };
    };

    // --- Core Game Logic ---
    const startGame = () => {
        resetState();
        state.trialList = generateTrialList();
        state.gameStartTime = Date.now();
        instructionModal.style.display = 'none';
        logEvent('game_start');
        nextTrial();
    };

    const generateTrialList = () => {
        let trials = [];
        for (const emotion of EMOTIONS) {
            for (let i = 1; i <= IMAGE_COUNT_PER_EMOTION; i++) {
                trials.push({ emotion: emotion, imageIndex: i });
            }
        }
        // Shuffle the trials array
        for (let i = trials.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [trials[i], trials[j]] = [trials[j], trials[i]];
        }
        return trials;
    };

    const nextTrial = () => {
        if (state.currentTrial >= TOTAL_TRIALS) {
            endGame(true);
            return;
        }

        feedbackEl.textContent = '';
        const trialData = state.trialList[state.currentTrial];
        state.currentCorrectEmotion = trialData.emotion;
        const imageIndex = ('0' + trialData.imageIndex).slice(-2); // Pad with zero
        faceImage.src = `${STATIC_IMG_PATH}${trialData.emotion}/${trialData.emotion}_${imageIndex}.jpg`;

        renderOptions();
        state.currentTrial++;
        updateDashboard();
        state.trialStartTime = Date.now();
        logEvent('trial_start', { correct_emotion: state.currentCorrectEmotion, image: faceImage.src });
    };

    const renderOptions = () => {
        optionsContainer.innerHTML = '';
        EMOTIONS.forEach(emotion => {
            const btn = document.createElement('button');
            btn.className = 'option-btn';
            btn.textContent = emotion.charAt(0).toUpperCase() + emotion.slice(1);
            btn.dataset.emotion = emotion;
            btn.addEventListener('click', () => handleChoice(emotion));
            optionsContainer.appendChild(btn);
        });
    };

    const handleChoice = (chosenEmotion) => {
        const reactionTime = Date.now() - state.trialStartTime;
        const isCorrect = chosenEmotion === state.currentCorrectEmotion;

        // Disable buttons after choice
        Array.from(optionsContainer.children).forEach(btn => btn.disabled = true);

        if (isCorrect) {
            state.correctCount++;
            feedbackEl.textContent = 'Correct!';
            feedbackEl.className = 'feedback correct';
        } else {
            feedbackEl.textContent = `Incorrect. The correct emotion was ${state.currentCorrectEmotion}.`;
            feedbackEl.className = 'feedback incorrect';
        }

        logEvent('trial_end', { choice: chosenEmotion, is_correct: isCorrect, reaction_time: reactionTime });
        updateDashboard();

        setTimeout(nextTrial, 2000);
    };

    const endGame = (completed) => {
        state.gameCompleted = completed;
        displayFinalResults();
        finalResultsModal.style.display = 'flex';
        sendDataToBackend();
    };

    // --- UI & Helpers ---
    const updateDashboard = () => {
        const accuracy = state.currentTrial > 0 ? (state.correctCount / state.currentTrial * 100).toFixed(0) : 100;
        accuracyEl.textContent = `${accuracy}%`;
        trialCounterEl.textContent = `${state.currentTrial}/${TOTAL_TRIALS}`;
    };

    const displayFinalResults = () => {
        const finalAccuracy = (state.correctCount / TOTAL_TRIALS * 100).toFixed(1);
        document.getElementById('final-summary').innerHTML = `
            <p style="font-size: 1.2rem;">You correctly identified <strong>${state.correctCount}</strong> out of <strong>${TOTAL_TRIALS}</strong> emotions.</p>
            <p style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">Final Accuracy: ${finalAccuracy}%</p>
        `;
    };

    // --- Data Handling ---
    const logEvent = (type, details = {}) => {
        state.events.push({ type, trial: state.currentTrial, timestamp: Date.now() - state.gameStartTime, ...details });
    };

    const sendDataToBackend = () => {
        const completionStatus = state.gameCompleted ? 'completed' : 'abandoned';
        const score = state.correctCount;
        const data = {
            game_name: GAME_ID,
            score: score,
            duration_ms: Date.now() - state.gameStartTime,
            completion_status: completionStatus,
            events: state.events,
            game_specific_data: { accuracy: (state.correctCount / TOTAL_TRIALS) }
        };

        return fetch('{% url "games:save_score" %}', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': gameBody.dataset.csrfToken },
            body: JSON.stringify(data),
        });
    };

    const quitGame = () => {
        if (state.gameStartTime === 0 || finalResultsModal.style.display === 'flex') {
            window.location.href = gameBody.dataset.gameListUrl;
            return;
        }
        state.gameCompleted = false;
        sendDataToBackend().finally(() => window.location.href = gameBody.dataset.gameListUrl);
    };

    // --- Event Listeners ---
    startGameBtn.addEventListener('click', startGame);
    backToGamesBtn.addEventListener('click', (e) => { e.preventDefault(); quitGame(); });
    returnToGamesFinalBtn.addEventListener('click', (e) => { e.preventDefault(); window.location.href = gameBody.dataset.gameListUrl; });
});
</script>
{% endblock %}
